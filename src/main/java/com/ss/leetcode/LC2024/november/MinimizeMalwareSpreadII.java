package com.ss.leetcode.LC2024.november;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

public class MinimizeMalwareSpreadII {
    // https://leetcode.com/problems/minimize-malware-spread-ii
    public int minMalwareSpread(int[][] graph, int[] initial) {
        List<Integer>[] connections = getConnections(graph);
        int minInfected = Integer.MAX_VALUE, nodeToRemove = Integer.MAX_VALUE;
        int currentlyInfected;
        for (int node : initial) {
            boolean[] infected = new boolean[graph.length];
            infected[node] = true;
            currentlyInfected = spreadMalware(connections, infected, initial);
            if (currentlyInfected < minInfected) {
                minInfected = currentlyInfected;
                nodeToRemove = node;
            } else if (currentlyInfected == minInfected) {
                nodeToRemove = Math.min(nodeToRemove, node);
            }
        }
        return nodeToRemove;
    }

    private int spreadMalware(List<Integer>[] connections, boolean[] isInfected, int[] initial) {
        Queue<Integer> nextToInfect = new LinkedList<>();
        int infectedCount = 1;
        for (int node : initial) {
            if (!isInfected[node]) {
                nextToInfect.add(node);
                isInfected[node] = true;
                infectedCount++;
            }
        }
        int size, currentInfectedNode;
        while (!nextToInfect.isEmpty()) {
            currentInfectedNode = nextToInfect.poll();
            if (connections[currentInfectedNode] != null) {
                for (int next : connections[currentInfectedNode]) {
                    if (!isInfected[next]) {
                        nextToInfect.add(next);
                        infectedCount++;
                        isInfected[next] = true;
                    }
                }
            }
        }
        return infectedCount;
    }

    private List<Integer>[] getConnections(int[][] graph) {
        List<Integer>[] connections = new List[graph.length];
        for (int i = 0; i < graph.length;i++) {
            for (int j = 0; j < graph[0].length; j++) {
                if (graph[i][j] == 1) {
                    if (connections[i] == null) {
                        connections[i] = new ArrayList<>();
                    }
                    if (connections[j] == null) {
                        connections[j] = new ArrayList<>();
                    }
                    connections[i].add(j);
                    connections[j].add(i);
                    graph[i][j] = 0;
                    graph[j][i] = 0;
                }
            }
        }
        return connections;
    }
}
